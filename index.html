// translate.js
const puppeteer = require('puppeteer');
const cheerio = require('cheerio');
const { translate } = require('@vitalets/google-translate-api');
const pluralize = require('pluralize');
const fs = require('fs');

// --- 配置常量 ---
const SOURCE_URL = 'https://en.tankiwiki.com/Tanki_Online_Wiki';
const DICTIONARY_URL = 'https://testanki1.github.io/translations.js';
const OUTPUT_DIR = './output';
const OUTPUT_FILE = `${OUTPUT_DIR}/index.html`;

// --- 1. 获取并准备词典 ---
async function getPreparedDictionary() {
    console.log(`正在从 URL 获取词典: ${DICTIONARY_URL}`);
    let originalDict;
    try {
        const response = await fetch(DICTIONARY_URL);
        if (!response.ok) { throw new Error(`网络请求失败: ${response.status}`); }
        const scriptContent = await response.text();
        originalDict = new Function(`${scriptContent}; return replacementDict;`)();
        console.log("在线词典加载成功。原始大小:", Object.keys(originalDict).length);
    } catch (error) {
        console.error("加载或解析在线词典时出错:", error);
        return { sortedKeys: [], dictionary: {} };
    }

    const preparedDict = { ...originalDict };
    const additions = {};
    for (const key in preparedDict) {
        if (Object.hasOwnProperty.call(preparedDict, key)) {
            const pluralKey = pluralize(key);
            if (pluralKey !== key && !preparedDict.hasOwnProperty(pluralKey) && !additions.hasOwnProperty(pluralKey)) {
                additions[pluralKey] = preparedDict[key];
            }
        }
    }
    Object.assign(preparedDict, additions);
    console.log("添加复数后词典大小:", Object.keys(preparedDict).length);

    const sortedKeys = Object.keys(preparedDict).sort((a, b) => b.length - a.length);
    
    return {
        sortedKeys,
        dictionary: preparedDict
    };
}

// --- 2. 创建一个全小写的占位符 ---
const makePlaceholder = (index) => `__final_ph_${index}__`;

// --- 3. 主函数 ---
async function run() {
    const { sortedKeys, dictionary } = await getPreparedDictionary();
    if (sortedKeys.length === 0) {
        console.log("警告: 词典为空。");
    }

    console.log('开始执行页面抓取...');
    const browser = await puppeteer.launch({ headless: true, args: ['--no-sandbox', '--disable-setuid-sandbox'] });
    const page = await browser.newPage();
    console.log(`正在导航到 ${SOURCE_URL}`);
    await page.goto(SOURCE_URL, { waitUntil: 'networkidle0' });
    const htmlContent = await page.content();
    await browser.close();
    console.log('页面抓取成功。');

    const $ = cheerio.load(htmlContent);

    // --- 内容提取 ---
    console.log('正在提取内容...');
    const $contentContainer = $('<div id="wiki-content"></div>');
    const $firstHeading = $('#firstHeading');
    if ($firstHeading.length) { $contentContainer.append($firstHeading.clone()); }

    const $contentBodyChildren = $('#mw-content-text .mw-parser-output').children();
    for (const el of $contentBodyChildren) {
        const $el = $(el);
        if ($el.find('small:contains("Last Edit")').length > 0) {
            console.log('已找到 "Last Edit"，内容提取停止。');
            $contentContainer.append($el.clone());
            break;
        }
        $contentContainer.append($el.clone());
    }
    console.log('内容提取完成。');

    // --- 修复链接 (这一步是安全的，因为它在翻译前执行) ---
    const WIKI_BASE_URL = 'https://en.tankiwiki.com';
    $contentContainer.find('img').each((i, el) => {
        const src = $(el).attr('src');
        if (src?.startsWith('/')) { $(el).attr('src', WIKI_BASE_URL + src); }
    });
    $contentContainer.find('a').each((i, el) => {
        const href = $(el).attr('href');
        if (href?.startsWith('/') || href?.startsWith(WIKI_BASE_URL)) {
            $(el).attr('href', new URL(href, WIKI_BASE_URL).pathname);
        }
    });
    console.log('URL 已处理。');

    // --- 【最终正确流程】 ---

    // 1. 安全地提取所有可见的文本节点
    const textNodes = [];
    $contentContainer.find('*:not(script,style)').addBack().contents().each(function() {
        if (this.type === 'text' && this.data.trim()) {
            textNodes.push(this);
        }
    });
    const originalTexts = textNodes.map(node => node.data);
    console.log(`总共找到 ${originalTexts.length} 个需要处理的文本片段。`);

    // 2. 保护术语：在纯文本数组上，将英文术语替换为占位符
    console.log('步骤 1/3: 正在保护自定义术语...');
    const placeholderMap = new Map();
    let placeholderIndex = 0;
    const protectedTexts = originalTexts.map(text => {
        let tempText = text;
        sortedKeys.forEach(key => {
            const escapedKey = key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(`\\b${escapedKey}\\b`, 'gi');
            tempText = tempText.replace(regex, (match) => {
                const placeholder = makePlaceholder(placeholderIndex);
                // 使用原始的、大小写正确的键来获取词典值
                // 如果词典里有大小写不同的同名键，这里需要更复杂的逻辑，但目前假设键是唯一的
                placeholderMap.set(placeholder, dictionary[key]);
                placeholderIndex++;
                return placeholder;
            });
        });
        return tempText;
    });
    console.log(`已创建 ${placeholderMap.size} 个占位符来保护术语。`);

    // 3. 翻译：将“受保护”的文本数组发送给谷歌
    let googleTranslatedTexts = protectedTexts;
    try {
        console.log('步骤 2/3: 正在翻译剩余的常规文本...');
        const translationPromises = protectedTexts.map(text =>
            translate(text, { to: 'zh-CN' }).then(res => res.text)
        );
        googleTranslatedTexts = await Promise.all(translationPromises);
        console.log('谷歌翻译完成。');
    } catch (error) {
        console.error('谷歌翻译 API 调用失败:', error);
    }

    // 4. 恢复术语：在翻译好的文本数组上，将占位符恢复为最终的中文
    console.log('步骤 3/3: 正在恢复受保护的术语...');
    const finalTexts = googleTranslatedTexts.map(text => {
        let restoredText = text;
        placeholderMap.forEach((chineseValue, placeholder) => {
            const regex = new RegExp(placeholder, 'g');
            restoredText = restoredText.replace(regex, chineseValue);
        });
        return restoredText;
    });
    
    // 5. 将最终的完美文本，安全地更新回原始的文本节点
    textNodes.forEach((node, index) => {
        if (finalTexts[index]) {
            node.data = finalTexts[index];
        }
    });
    console.log('翻译结果已成功还原至页面。');
    
    // --- 构建最终页面 ---
    const finalHtmlContent = $contentContainer.html();
    const finalHtml = `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D坦克维基（中文翻译）</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+1p&family=Rubik:wght@400;700&display=swap" rel="stylesheet">
    ${$('head').html()}
    <style>
        body { background-color: #001926 !important; font-family: 'Rubik', 'M PLUS 1p', sans-serif !important; }
        a { color: #76FF33 !important; }
        .mw-body-content, .mw-body-content div, .mw-body-content p, .mw-body-content li, .mw-body-content h1, .mw-body-content h2, .mw-body-content h3, .mw-body-content h4, .mw-body-content h5, .mw-body-content span { color: #E0E0E0 !important; background-color: transparent !important; }
        #firstHeading { color: #FFFFFF !important; border-bottom-color: #444 !important; }
        .navigationContainer { background-color: #002538 !important; border-color: #004060 !important; }
        .alert.success { background-color: #0c3d25 !important; border-color: #198754 !important; }
    </style>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Tanki_Online_Wiki rootpage-Tanki_Online_Wiki skin-tankiblue action-view">
    <div id="mw-main-container" style="max-width: 1200px; margin: 20px auto; background-color: #001926;">
        <div class="main-content">
            <div class="mw-body ve-init-mw-desktopArticleTarget-targetContainer" id="content" role="main">
                <div class="mw-body-content" id="bodyContent">
                    <div id="mw-content-text" class="mw-content-ltr mw-parser-output" lang="zh-CN" dir="ltr">
                        ${finalHtmlContent}
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>`;
    console.log('最终的 HTML 页面已构建。');

    if (!fs.existsSync(OUTPUT_DIR)) { fs.mkdirSync(OUTPUT_DIR, { recursive: true }); }
    fs.writeFileSync(OUTPUT_FILE, finalHtml);
    console.log(`翻译完成。文件已保存到 ${OUTPUT_FILE}`);
}

run();
